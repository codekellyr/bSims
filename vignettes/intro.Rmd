---
title: "Introduction"
author: "Peter Solymos"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The **bSims** R package is a _highly scientific_ and _utterly addictive_ bird point count simulator. Highly scientific, because it implements a spatially
explicit mechanistic simulation that is based on statistical models
widely used in bird point count analysis (i.e. removal models, distance 
sampling), and utterly addictive because the implementation
is designed to allow rapid exploration (via Shiny apps)
and efficient simulation (supporting various parallel backends),
thus elevating the user experiance.

The goals of the package are to (1) allow easy testing of
statistical assumptions and explore effects of violating these assumptions,
to (2) aid survey design by comparing different options, and most
importantly, to (3) have fun while doing it.

## Simulation layers

Introductory stats books begin with the coin flip to introduce
the binomial distribution. In R we can easily simulate
an outcome from such a random variable
$Y \sim Binomial(1, p)$ doing something like this:

```{r Bin,eval=FALSE}
p <- 0.5

Y <- rbinom(1, size = 1, prob = p)
```

But a coin flip in reality is a lot more complicated: we might consider 
the initial forece, the height of the toss, the spin, 
and the weight of the coin.

Bird behaviour combined with the observation process presents
a more complicated system, that is often treated as a mixture of
a count distribution and a detection/nondetection process, e.g.:

```{r Pois,eval=FALSE}
D <- 2 # individuals / unit area
A <- 1 # area
p <- 0.8 # probability of availability given presence
q <- 0.5 # probability of detection given availability

N <- rpois(1, lambda = A * D)
Y <- rbinom(1, size = N, prob = p * q)
```

This looks not too complicated, corresponding to the true abundance
being a random variables $N \sim Poisson(DA)$, while the observed count
being $Y \sim Binomial(N, pq)$.
This is the exact simulation
that we need when we want to make sure that an _estimator_
is capable of estimating the _model_ parameters (`lambda` and `prob` here).
But such probabilistic simulations are not wery useful when we are
interested how well the _model_ captures important aspects of _reality_.

Going back to the Poisson--Binomial example, `N` would be a result
of all the factors influencing burd abundance, such as
geographical location, season, habitat suitability, number of
conspecifics, competitors, or predators. `Y` however would
largely depend on how the birds behave depending on timing,
or how an observer might detect or miss the different individuals,
or count the same indivual twice, etc.

Therefore the package has layers, that by default are 
_conditionally independent_ of each other. This design decision
is meant to facilitate the comparison of certaing settings
while keeping all the underlying realizations identical, thus
helping to pinpoint effects without the extra variability introduced
by all the other effects.

The conditionally independent _layers_ of a 
**bSims** realization are the following, with the corresponding function:

1. landscape (`bsims_init`),
2. population (`bsims_populate`),
3. behaviour with movement and vocalization events (`bsims_animate`),
4. the phisical side of the observation process (`bsims_detect`), and
5. the human aspect of the observation process (`bsims_transcribe`).

See ths example as a sneak peek that we'll explain in the following sections:

```{r gen,fig.height=6,fig.width=6}
library(bSims)

phi <- 0.5                 # singing rate
tau <- 1:3                 # EDR by strata
dur <- 10                  # simulation duration
tbr <- c(3, 5, 10)         # time intervals
rbr <- c(0.5, 1, 1.5, Inf) # counting radii

l <- bsims_init(10, 0.5, 1)# landscape
p <- bsims_populate(l, 1)  # population
e <- bsims_animate(p,      # events
  vocal_rate=phi, duration=dur)
d <- bsims_detect(e,       # detections
  tau=tau)
x <- bsims_transcribe(d,   # transcription
  tint=tbr, rint=rbr)

plot(x)
get_table(x)
head(get_events(a))
head(get_detections(o))
```

### Landscape

Args and what they do, cover support functions, use examples from Rd, cover theory briefly

```{r eval=FALSE}
l1 <- bsims_init(extent = 10, road = 0, edge = 0, offset = 0)
l2 <- bsims_init(extent = 10, road = 1, edge = 1, offset = 0)
l3 <- bsims_init(extent = 10, road = 1, edge = 1, offset = 2)
l4 <- bsims_init(extent = 10, road = 0, edge = 5, offset = 5)

op <- par(mfrow = c(2, 2), mar = c(1, 1, 1, 1))
plot(l1, main = "Habitat (H)")
plot(l2, main = "Habitat/edge/road (HER)")
plot(l3, main = "HER with offset")
plot(l4, main = "2 habitats")
par(op)
```

### Population

Args and what they do, cover support functions, use examples from Rd, cover theory briefly

```{r eval=FALSE}
bsims_populate(x, density = 1, abund_fun = NULL, xy_fun = NULL,
  margin = 0, maxit = 100, fail = FALSE, ...)

## complete spatial randomness
plot(acceptreject(100), asp=1)

## more systematic
distance <- seq(0,1,0.01)
f <- function(d)
  (1-exp(-d^2/0.1^2) + dlnorm(d, 0.2)/dlnorm(exp(0.2-1),0.2)) / 2
op <- par(mfrow = c(1, 2))
plot(distance, f(distance), type="l")
plot(acceptreject(100, f, m=1), asp=1)
par(op)

## more clustered
f <- function(d)
  exp(-d^2/0.1^2) + 0.5*(1-exp(-d^2/0.4^2))
op <- par(mfrow = c(1, 2))
plot(distance, f(distance), type="l")
plot(acceptreject(100, f, m=1), asp=1)
par(op)

# explain density=c(1,2,3)
```


### Behaviour

Args and what they do, cover support functions, use examples from Rd, cover theory briefly

```{r eval=FALSE}
bsims_animate(x, vocal_rate = 1, move_rate = 0, duration = 10,
  movement = 0, mixture = 1, avoid = c("none", "R", "ER"),
  initial_location=FALSE, allow_overlap=TRUE, ...)

timetoevent(0, 10)
timetoevent(Inf, 10)

rr <- 1
tt <- timetoevent(rr, 10)
op <- par(mfrow=c(1,2))
plot(ecdf(tt))
curve(1-exp(-rr*x), add=TRUE, col=2) # cdf

plot(stepfun(sort(tt), 0:length(tt)/length(tt)), ylab="F(x)")
curve(1-exp(-rr*x), add=TRUE, col=2) # cdf
par(op)

e <- events(movement=1, duration=60)
mx <- max(abs(e[,1:2]))
plot(e[,1:2], col="grey", type="l", asp=1,
  xlim=2*c(-mx, mx), ylim=2*c(-mx, mx))
points(e[,1:2], col=e$v+1)
abline(h=0, v=0, lty=2)
legend("topright", pch=21, col=1:2, horiz=TRUE,
  legend=c("movement", "vocalization"))


```

### Detection

Args and what they do, cover support functions, use examples from Rd, cover theory briefly

```{r eval=FALSE}
bsims_detect(x, xy = c(0, 0), tau = 1, dist_fun = NULL,
  event_type = c("vocal", "move", "both"), ...)

# distance function exploration
```

### Transcription

Args and what they do, cover support functions, use examples from Rd, cover theory briefly


```{r eval=FALSE}
bsims_transcribe(x, tint = NULL, rint = Inf, error = 0,
  condition=c("event1", "det1", "alldet"),
  event_type=NULL, perception=NULL, ...)
```

## Simulation workflows

- Shiny apps: interactive exploration, copy/paste
- define corner cases
- use `expand_list` and `bsims_all`

## Single habitat case

```{r H,fig.height=10,fig.width=10}
phi <- 0.5
tau <- 2
Den <- 10

set.seed(1)
l <- bsims_init()
a <- bsims_populate(l, density=Den)
b <- bsims_animate(a, vocal_rate=phi)
o <- bsims_detect(b, tau=tau)

tint <- c(1, 2, 3, 4, 5)
rint <- c(0.5, 1, 1.5, 2) # truncated at 200 m
(tr <- bsims_transcribe(o, tint=tint, rint=rint))
(rem <- tr$removal) # binned new individuals
colSums(rem)
rowSums(rem)
plot(tr)
```

Estimating density with truncation in the single habitat case:

```{r Dtr}
library(detect)

## singing rate
fitp <- cmulti.fit(matrix(colSums(rem), 1), matrix(tint, 1), type="rem")
phihat <- exp(fitp$coef)
c(true=phi, estimate=exp(fitp$coef))
(p <- 1-exp(-max(tint)*phihat))

## EDR
fitq <- cmulti.fit(matrix(rowSums(rem), 1), matrix(rint, 1), type="dis")
tauhat <- exp(fitq$coef)
c(true=tau, estimate=tauhat)
rmax <- max(rint)
(q <- (tauhat^2/rmax^2) * (1-exp(-(rmax/tauhat)^2)))

## density
(A <- pi * rmax^2)
Dhat <- sum(rem) / (A * p * q)
c(true=Den, estimate=Dhat)
```

Estimating density with unlimited distance in the single habitat case:

```{r Dinf}
rint <- c(0.5, 1, 1.5, 2, Inf) # unlimited

(tr <- bsims_transcribe(o, tint=tint, rint=rint))
(rem <- tr$removal) # binned new individuals
colSums(rem)
rowSums(rem)

fitp <- cmulti.fit(matrix(colSums(rem), 1), matrix(tint, 1), type="rem")
phihat <- exp(fitp$coef)
c(true=phi, estimate=phihat)
(p <- 1-exp(-max(tint)*phihat))

fitq <- cmulti.fit(matrix(rowSums(rem), 1), matrix(rint, 1), type="dis")
tauhat <- exp(fitq$coef)
c(true=tau, estimate=tauhat)

(Ahat <- pi * tauhat^2)
q <- 1

Dhat <- sum(rem) / (Ahat * p * q)
c(true=Den, estimate=Dhat)
```

We have used so far a single location.
We also set the density unreasonably high to have enough 
counts for a reasonable estimate.
We can independently replicate the simulation for multiple
landscapes and analyze the results:

```{r Dx, eval=FALSE}
phi <- 0.5
tau <- 1
Den <- 1

tint <- c(3, 5, 10)
rint <- c(0.5, 1, 1.5, Inf)

sim_fun <- function() {
  l <- bsims_init()
  a <- bsims_populate(l, density=Den)
  b <- bsims_animate(a, vocal_rate=phi)
  o <- bsims_detect(b, tau=tau)
  bsims_transcribe(o, tint=tint, rint=rint)$rem
}

B <- 200
set.seed(123)
res <- pbapply::pbreplicate(B, sim_fun(), simplify=FALSE)

Ddur <- matrix(tint, B, length(tint), byrow=TRUE)
Ydur1 <- t(sapply(res, function(z) colSums(z)))
Ydur2 <- t(sapply(res, function(z) colSums(z[-nrow(z),])))
colSums(Ydur1) / sum(Ydur1)
colSums(Ydur2) / sum(Ydur2)
fitp1 <- cmulti(Ydur1 | Ddur ~ 1, type="rem")
fitp2 <- cmulti(Ydur2 | Ddur ~ 1, type="rem")
phihat1 <- unname(exp(coef(fitp1)))
phihat2 <- unname(exp(coef(fitp2)))

Ddis1 <- matrix(rint, B, length(rint), byrow=TRUE)
Ddis2 <- matrix(rint[-length(rint)], B, length(rint)-1, byrow=TRUE)
Ydis1 <- t(sapply(res, function(z) rowSums(z)))
Ydis2 <- t(sapply(res, function(z) rowSums(z)[-length(rint)]))
colSums(Ydis1) / sum(Ydis1)
colSums(Ydis2) / sum(Ydis2)
fitq1 <- cmulti(Ydis1 | Ddis1 ~ 1, type="dis")
fitq2 <- cmulti(Ydis2 | Ddis2 ~ 1, type="dis")
tauhat1 <- unname(exp(fitq1$coef))
tauhat2 <- unname(exp(fitq2$coef))

## unlimited correction
Apq1 <- pi * tauhat1^2 * (1-exp(-max(tint)*phihat1)) * 1
rmax <- max(rint[is.finite(rint)])
## truncated correction
Apq2 <- pi * rmax^2 * 
  (1-exp(-max(tint)*phihat2)) * 
  (tauhat2^2/rmax^2) * (1-exp(-(rmax/tauhat2)^2))

round(rbind(
  phi=c(true=phi, unlimited=phihat1, truncated=phihat2),
  tau=c(true=tau, unlimited=tauhat1, truncated=tauhat2),
  D=c(Den, unlimited=mean(rowSums(Ydis1))/Apq1,
      truncated=mean(rowSums(Ydis2))/Apq2)), 4)
```

## Shiny apps

Play with detection functions:

```{r shiny1,eval=FALSE}
run_app("distfunH")
run_app("distfunHER")
```

Play with simulations and explore biases in a single-habitat setting (see also https://psolymos.shinyapps.io/bSimsH/):

```{r shiny2,eval=FALSE}
run_app("bsimsH")
```

Play with simulations and explore biases in a stratified habitat setting with road and edge (see also https://psolymos.shinyapps.io/bSimsHER/):

```{r shiny3,eval=FALSE}
run_app("bsimsHER")
```

Shiny apps can be used to play with the settings, then
settings copied to the clipboard and eventually into R.

